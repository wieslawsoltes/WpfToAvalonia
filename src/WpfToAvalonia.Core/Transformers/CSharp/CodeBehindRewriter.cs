using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using WpfToAvalonia.Core.Diagnostics;
using WpfToAvalonia.Core.Visitors;
using WpfToAvalonia.Mappings;

namespace WpfToAvalonia.Core.Transformers.CSharp;

/// <summary>
/// Rewrites code-behind files from WPF to Avalonia.
/// Implements task 2.5.6.2: Code-behind integration
/// </summary>
/// <remarks>
/// Code-behind transformation includes:
///
/// Task 2.5.6.2.1: Parse x:Class and x:Name mappings
/// - Extract x:Class from XAML to identify the partial class
/// - Parse x:Name attributes to identify named elements
/// - Create mapping between XAML names and expected field declarations
///
/// Task 2.5.6.2.2: Generate field declarations for named elements
/// - Generate private fields for x:Name elements (if missing)
/// - Update field types from WPF to Avalonia equivalents
/// - Add nullable annotations where appropriate
///
/// Task 2.5.6.2.3: Coordinate with C# transformer for code-behind updates
/// - Ensure field types match transformed XAML element types
/// - Validate that code-behind class matches x:Class attribute
/// - Coordinate event handler transformations
///
/// Task 2.5.6.2.4: Handle partial class generation patterns
/// - Ensure partial class keyword is present
/// - Update base class from WPF to Avalonia (Window → Avalonia.Controls.Window)
/// - Update using directives for Avalonia namespaces
///
/// Task 2.5.6.2.5: Support InitializeComponent transformation
/// - Transform InitializeComponent() calls
/// - Update from System.Windows.Markup to Avalonia.Markup.Xaml
/// - Change AvaloniaXamlLoader.Load(this) pattern
///
/// WPF Pattern:
/// ```csharp
/// public partial class MainWindow : Window
/// {
///     public MainWindow()
///     {
///         InitializeComponent();
///     }
/// }
/// ```
///
/// Avalonia Pattern:
/// ```csharp
/// public partial class MainWindow : Window
/// {
///     public MainWindow()
///     {
///         InitializeComponent();
///     }
///
///     private void InitializeComponent()
///     {
///         AvaloniaXamlLoader.Load(this);
///     }
/// }
/// ```
///
/// Or using source generators (Avalonia 11+):
/// ```csharp
/// public partial class MainWindow : Window
/// {
///     public MainWindow()
///     {
///         InitializeComponent();
///     }
///     // InitializeComponent is generated by source generator
/// }
/// ```
/// </remarks>
public sealed class CodeBehindRewriter : WpfToAvaloniaRewriter
{
    private readonly Dictionary<string, string> _namedElements;
    private int _initializeComponentCalls;
    private int _partialClassesUpdated;
    private int _baseClassesUpdated;
    private int _fieldsGenerated;
    private int _xClassValidations;

    /// <summary>
    /// Initializes a new instance of the <see cref="CodeBehindRewriter"/> class.
    /// </summary>
    public CodeBehindRewriter(
        SemanticModel semanticModel,
        DiagnosticCollector diagnostics,
        IMappingRepository mappingRepository)
        : base(semanticModel, diagnostics, mappingRepository)
    {
        _namedElements = new Dictionary<string, string>();
    }

    /// <summary>
    /// Initializes a new instance with x:Name mappings from XAML.
    /// </summary>
    public CodeBehindRewriter(
        SemanticModel semanticModel,
        DiagnosticCollector diagnostics,
        IMappingRepository mappingRepository,
        Dictionary<string, string> namedElements)
        : base(semanticModel, diagnostics, mappingRepository)
    {
        _namedElements = namedElements ?? new Dictionary<string, string>();
    }

    /// <summary>
    /// Gets the number of InitializeComponent calls detected.
    /// </summary>
    public int InitializeComponentCalls => _initializeComponentCalls;

    /// <summary>
    /// Gets the number of partial classes updated.
    /// </summary>
    public int PartialClassesUpdated => _partialClassesUpdated;

    /// <summary>
    /// Gets the number of base classes updated.
    /// </summary>
    public int BaseClassesUpdated => _baseClassesUpdated;

    /// <summary>
    /// Gets the number of fields generated for named elements.
    /// </summary>
    public int FieldsGenerated => _fieldsGenerated;

    /// <summary>
    /// Gets the number of x:Class validations performed.
    /// </summary>
    public int XClassValidations => _xClassValidations;

    /// <summary>
    /// Sets the x:Name to type mapping from XAML parsing.
    /// </summary>
    /// <param name="name">The x:Name value</param>
    /// <param name="typeName">The element type name</param>
    public void AddNamedElement(string name, string typeName)
    {
        _namedElements[name] = typeName;
    }

    /// <summary>
    /// Visits class declarations to handle code-behind transformations.
    /// Handles tasks 2.5.6.2.1, 2.5.6.2.3, and 2.5.6.2.4.
    /// </summary>
    public override SyntaxNode? VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        var classSymbol = TryGetDeclaredSymbol(node);
        if (classSymbol == null)
        {
            return base.VisitClassDeclaration(node);
        }

        // Task 2.5.6.2.4: Ensure partial class keyword
        if (!node.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
        {
            Diagnostics.AddWarning(
                "CODE_BEHIND_MISSING_PARTIAL",
                $"Code-behind class '{node.Identifier.Text}' should be marked as partial. " +
                $"Add 'partial' keyword: public partial class {node.Identifier.Text}",
                null);
        }

        // Task 2.5.6.2.4: Check and update base class
        if (node.BaseList != null)
        {
            foreach (var baseType in node.BaseList.Types)
            {
                var baseTypeName = baseType.Type.ToString();

                // Check for WPF base types
                if (IsWpfControlBaseType(baseTypeName))
                {
                    var avaloniaBaseType = GetAvaloniaBaseType(baseTypeName);
                    if (avaloniaBaseType != baseTypeName)
                    {
                        _baseClassesUpdated++;
                        Diagnostics.AddInfo(
                            "CODE_BEHIND_BASE_CLASS",
                            $"Update base class from '{baseTypeName}' to '{avaloniaBaseType}' in class '{node.Identifier.Text}'",
                            null);
                    }
                }
            }
        }

        // Task 2.5.6.2.1 & 2.5.6.2.3: Validate x:Class matching
        _xClassValidations++;
        var fullName = classSymbol.ToDisplayString();
        Diagnostics.AddInfo(
            "CODE_BEHIND_XCLASS_INFO",
            $"Code-behind class: {fullName}. Ensure this matches the x:Class attribute in the XAML file.",
            null);

        // Task 2.5.6.2.2: Check for missing field declarations for named elements
        CheckMissingNamedElementFields(node, classSymbol);

        _partialClassesUpdated++;
        return base.VisitClassDeclaration(node);
    }

    /// <summary>
    /// Checks if a base type name is a WPF control base type.
    /// </summary>
    private bool IsWpfControlBaseType(string baseTypeName)
    {
        var wpfBaseTypes = new[]
        {
            "Window", "UserControl", "Page", "Control",
            "System.Windows.Window", "System.Windows.Controls.UserControl",
            "System.Windows.Controls.Page", "System.Windows.Controls.Control"
        };

        return wpfBaseTypes.Any(wpfType =>
            baseTypeName == wpfType || baseTypeName.EndsWith("." + wpfType));
    }

    /// <summary>
    /// Gets the Avalonia equivalent of a WPF base type.
    /// </summary>
    private string GetAvaloniaBaseType(string wpfBaseType)
    {
        // Strip namespace if present
        var simpleType = wpfBaseType.Split('.').Last();

        return simpleType switch
        {
            "Window" => "Avalonia.Controls.Window",
            "UserControl" => "Avalonia.Controls.UserControl",
            "Page" => "Avalonia.Controls.UserControl", // Page → UserControl in Avalonia
            "Control" => "Avalonia.Controls.Control",
            _ => wpfBaseType
        };
    }

    /// <summary>
    /// Task 2.5.6.2.2: Checks for missing field declarations for named XAML elements.
    /// </summary>
    private void CheckMissingNamedElementFields(ClassDeclarationSyntax classNode, INamedTypeSymbol classSymbol)
    {
        if (_namedElements.Count == 0)
        {
            return; // No named elements to check
        }

        // Get all field names in the class
        var existingFields = classNode.Members
            .OfType<FieldDeclarationSyntax>()
            .SelectMany(f => f.Declaration.Variables)
            .Select(v => v.Identifier.Text)
            .ToHashSet();

        // Check each named element
        foreach (var namedElement in _namedElements)
        {
            var elementName = namedElement.Key;
            var elementType = namedElement.Value;

            if (!existingFields.Contains(elementName))
            {
                _fieldsGenerated++;

                // Map WPF type to Avalonia type
                var avaloniaType = MapTypeNameToAvalonia(elementType);

                Diagnostics.AddWarning(
                    "CODE_BEHIND_MISSING_FIELD",
                    $"Missing field declaration for x:Name='{elementName}'. " +
                    $"Add: private {avaloniaType}? {elementName}; " +
                    $"(Original WPF type: {elementType})",
                    null);
            }
            else
            {
                // Field exists, check if type needs updating
                var field = classNode.Members
                    .OfType<FieldDeclarationSyntax>()
                    .SelectMany(f => f.Declaration.Variables.Select(v => new { Field = f, Variable = v }))
                    .FirstOrDefault(fv => fv.Variable.Identifier.Text == elementName);

                if (field != null)
                {
                    var fieldTypeName = field.Field.Declaration.Type.ToString();
                    var avaloniaType = MapTypeNameToAvalonia(elementType);

                    if (!TypesAreEquivalent(fieldTypeName, avaloniaType))
                    {
                        Diagnostics.AddWarning(
                            "CODE_BEHIND_FIELD_TYPE_MISMATCH",
                            $"Field '{elementName}' has type '{fieldTypeName}' but XAML element type is '{elementType}'. " +
                            $"Update field type to: {avaloniaType}",
                            null);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Maps a WPF type name to its Avalonia equivalent.
    /// </summary>
    private string MapTypeNameToAvalonia(string wpfType)
    {
        // Use the mapping repository if available
        var mapping = MappingRepository.FindTypeMapping(wpfType);
        if (mapping != null && !string.IsNullOrEmpty(mapping.AvaloniaTypeName))
        {
            return mapping.AvaloniaTypeName;
        }

        // Common WPF to Avalonia type mappings
        return wpfType switch
        {
            "System.Windows.Controls.Button" => "Avalonia.Controls.Button",
            "System.Windows.Controls.TextBox" => "Avalonia.Controls.TextBox",
            "System.Windows.Controls.TextBlock" => "Avalonia.Controls.TextBlock",
            "System.Windows.Controls.ListBox" => "Avalonia.Controls.ListBox",
            "System.Windows.Controls.ComboBox" => "Avalonia.Controls.ComboBox",
            "System.Windows.Controls.Grid" => "Avalonia.Controls.Grid",
            "System.Windows.Controls.StackPanel" => "Avalonia.Controls.StackPanel",
            "System.Windows.Controls.Border" => "Avalonia.Controls.Border",
            "System.Windows.Controls.Label" => "Avalonia.Controls.Label",
            "System.Windows.Controls.CheckBox" => "Avalonia.Controls.CheckBox",
            "System.Windows.Controls.RadioButton" => "Avalonia.Controls.RadioButton",
            _ => wpfType.Replace("System.Windows.Controls.", "Avalonia.Controls.")
                       .Replace("System.Windows.", "Avalonia.Controls.")
        };
    }

    /// <summary>
    /// Checks if two type names are equivalent (accounting for namespaces).
    /// </summary>
    private bool TypesAreEquivalent(string type1, string type2)
    {
        // Simple name comparison
        var simple1 = type1.Split('.').Last().TrimEnd('?');
        var simple2 = type2.Split('.').Last().TrimEnd('?');

        return simple1 == simple2;
    }

    /// <summary>
    /// Task 2.5.6.2.5: Visits invocation expressions to detect InitializeComponent calls.
    /// </summary>
    public override SyntaxNode? VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        if (node.Expression is IdentifierNameSyntax identifier &&
            identifier.Identifier.Text == "InitializeComponent")
        {
            _initializeComponentCalls++;

            Diagnostics.AddInfo(
                "CODE_BEHIND_INITIALIZE_COMPONENT",
                $"InitializeComponent() call detected. " +
                $"For Avalonia 11+ with source generators, this will be auto-generated. " +
                $"For manual implementation, ensure InitializeComponent() contains: AvaloniaXamlLoader.Load(this); " +
                $"Also ensure 'using Avalonia.Markup.Xaml;' is present.",
                null);
        }

        return base.VisitInvocationExpression(node);
    }

    /// <summary>
    /// Visits method declarations to check for InitializeComponent implementation.
    /// </summary>
    public override SyntaxNode? VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        if (node.Identifier.Text == "InitializeComponent")
        {
            var methodBody = node.Body?.ToString() ?? "";

            if (methodBody.Contains("AvaloniaXamlLoader.Load"))
            {
                Diagnostics.AddInfo(
                    "CODE_BEHIND_AVALONIA_LOADER",
                    $"InitializeComponent() already contains AvaloniaXamlLoader.Load(this). Good!",
                    null);
            }
            else if (methodBody.Contains("System.Windows.Application.LoadComponent"))
            {
                Diagnostics.AddWarning(
                    "CODE_BEHIND_WPF_LOAD_COMPONENT",
                    $"InitializeComponent() uses WPF's LoadComponent. " +
                    $"Replace with: AvaloniaXamlLoader.Load(this); " +
                    $"Add using: using Avalonia.Markup.Xaml;",
                    null);
            }
            else if (string.IsNullOrWhiteSpace(methodBody) || methodBody.Contains("partial"))
            {
                Diagnostics.AddInfo(
                    "CODE_BEHIND_GENERATED_INITIALIZE",
                    $"InitializeComponent() appears to be auto-generated (partial method or empty). " +
                    $"This is correct for Avalonia 11+ source generator approach.",
                    null);
            }
        }

        return base.VisitMethodDeclaration(node);
    }

    /// <summary>
    /// Visits using directives to check for XAML loader imports.
    /// </summary>
    public override SyntaxNode? VisitUsingDirective(UsingDirectiveSyntax node)
    {
        var usingName = node.Name?.ToString() ?? "";

        if (usingName == "System.Windows.Markup" || usingName.StartsWith("System.Windows.Markup."))
        {
            Diagnostics.AddInfo(
                "CODE_BEHIND_USING_MARKUP",
                $"WPF markup using detected: '{usingName}'. " +
                $"For Avalonia, ensure you have: using Avalonia.Markup.Xaml;",
                null);
        }

        return base.VisitUsingDirective(node);
    }

    /// <summary>
    /// Tries to get declared symbol, catching exceptions from stale semantic models.
    /// </summary>
    private INamedTypeSymbol? TryGetDeclaredSymbol(ClassDeclarationSyntax node)
    {
        try
        {
            return SemanticModel.GetDeclaredSymbol(node) as INamedTypeSymbol;
        }
        catch
        {
            return null;
        }
    }
}
